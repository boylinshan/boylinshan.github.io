---
layout: post
title: '任务系统-客户端设计'
category: Work
---

# 客户端

## 初版

任务系统客户端部分对应了玩家在游戏中的具体操作。由服务器触发执行后的执行流程如下:

![RPyC](/img/client_flow.png)

1.	每次服务器发送请求后，客户端创建一个对应的Executor.
2.	判断是否可执行，当前没有正在执行的Executor或者当前的可被打断.
3.	将Executor添加到Avatar，作为当前运行的Executor.
4.	执行具体的程序流程.
5.	执行完成后，向服务器发送完成信息，并从Avatar上删除.
在任何时候保证了当前只有一个任务在运行。玩家的操作会中断任务的执行，需服务器再次发送执行指令。

## 修改版

由于之前的任务都是基于自动寻路的，并且任何时候都只有一个任务在运行。无法满足策划的需求。策划希望任务可以支持非自动寻路的形式完成并且可以有多个任务同时处于可完成状态，并且支持玩家点击NPC完成任务的方式。因此在最初版本的基础上进行了扩展:

![RPyC](/img/Executor.png)

修改后一般的Executor继承自PhaseExecutor，PhaseExecutor继承了DetourExecutor和RegionExecutor。PhaseExecutor根据是否自动寻路表现出不同的行为。DetourExecutor表现与之前相同，并没有进行修改，而RegionExecutor采用触发器的方式来进行任务，例如采集图标的出现，播放动画以及传送等等。此外在Avatar上保留了所有处于运行状态的RegionExecutor，也即是多个任务的触发器同时处于运行的状态。

## 需求变更

### 需求变更-1

对于自动寻路的任务，策划希望寻路完成后并不触发后续任务的进行，而是同样通过点击NPC的方式进行任务。

### 处理-1

将DetourExecutor同样加入到运行中队列，这样点击NPC时便可以显示当前正在进行的DetourExecutor。然而在此之前DetourExecutor是在每次执行时创建一个实例，并在完成或者被用户打断后消失，保证了当前仅有一个DetourExecutor进行，而当将DetourExecutor加入到运行队列后，实例将持续存在，与原始的运行流程不一致，此时任务系统客户端逻辑开始变得有些混乱。

### 需求变更-2

对于自动寻路的任务，策划希望更改为之前的形式，即寻路完成后立即触发后续的流程，与此同时保留玩家点击NPC执行任务的形式。

### 处理-2

恢复DetourExecutor原始的执行流程，并在开始时添加至运行队列，完成时从运行队列里删除。

### 需求变更-3

对于某些类型的任务，策划希望在支持自动寻路的同时支持触发器的功能。例如场景交互Phase。

### 处理-3

特殊处理场景交互Phase，自动寻路同时，添加触发器。然而在此种情况下，原有的结构已经完全不起作用，而是根据需求而进行的特殊处理。

## 总结

到此为止任务系统的客户端部分已变的相当混乱，不利于后续的开发，有必要进行一次修正。综上可知混乱的原因有几点。
1. 刚接手时并没有很好的与策划进行需求沟通，只是针对策划的想法扩张了原有的程序。然而很多情况下，策划所描述的并不是你所需要实现的，例如：策划并不是需求非自动寻路的功能，而只是觉得原有自动寻路的任务执行方式不合理。
2. 需求更改过多。策划在设计游戏时，很难一步到达完善的地步，需求的变更是必然。程序也要及时的进行结构上的修改，而并不只是表现上符合需求即可。

其实总结下就是，刚接手遇上需求变更加上任务多以及偷懒导致的。趁着这周项目处于空闲期，还是将结果迭代一下比较好。

## 问题及修改方案

### 自动寻路

在任务系统当前的机构中，PhaseExecutor通过多继承来支持两种不同的触发方式。DetourExecutor用于寻路，RegionExecutor用于检测玩家的位置，PhaseExecutor通过auto_detour字段判断应该调用哪一个函数。然而这种实现方式是没有必要的，程序可以使用创建私有trap的方式取代RegionExecutor的功能，这样一来不仅符合游戏整体上的结构，任务系统自身结构上也显的更加清晰。因此在新的设计中，Executor采用的单继承的方式，并提供了两种触发接口，由具体的Executor具体实现。类关系图如下所示。

![RPyC](/img/new_executor.png)

与之前的相比，新的结构显的简单了许多。Executor执行时首先调用do_execute，此函数仅执行寻路操作(非自动寻路任务，则do nothing)。寻路完成后调用on_arrived_destination，执行后续的操作。同时PhaseExecutor为私有Trap提供了on_enter_region和on_exit_region接口，具体的执行流程也由具体的Executor决定。

值得注意的是，是否自动寻路和是否产生Trap虽然由策划填表确定，但仍需在程序里处理同时触发多次的情况，有可能由策划填错或者其他异常引起。为了保证安全此种情况在服务器解决，简单的讲就是在服务器上任务的Phase中设置标记位。

### Executor管理

Executor作为任务系统客户端具体流程执行的载体，并不需要保持中间状态，仅仅完成一系列的操作即可。因此在最初的设计中，仅在服务器发送请求时创建，被中断后即销毁，并不会保留。然而为了满足多个任务同时可执行的需求，Executor也需要保存。在此种情况下，Executor依然不存在中间状态，仅仅是为了执行一段操作，只是因为客户端无法根据task_id从自身获取到任务当前对应的Executor，因而需要将服务器上任务的状态保存下来。在设计中始终以服务器的最新状态为准。